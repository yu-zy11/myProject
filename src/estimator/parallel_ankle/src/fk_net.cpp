
#include "parallel_ankle/fk_net.h"

#include <iostream>

namespace core {
namespace estimator {

void MapminmaxApply(Eigen::ArrayXd x, Eigen::Matrix<double, -1, 3> settings, Eigen::VectorXd& y) {
  Eigen::ArrayXd xoffset = settings.block<2, 1>(0, 0);
  Eigen::ArrayXd gain = settings.block<2, 1>(0, 1);
  Eigen::ArrayXd ymin = settings.block<2, 1>(0, 2);
  y = (x - xoffset) * gain + ymin;
}

void TansigApply(Eigen::ArrayXd n, Eigen::VectorXd& a) { a = 2 / (1 + exp(-2 * n)) - 1; }

void MapminmaxReverse(Eigen::VectorXd y, Eigen::Matrix<double, -1, 3> settings, Eigen::VectorXd& x) {
  Eigen::ArrayXd xoffset = settings.block<2, 1>(0, 0);
  Eigen::ArrayXd gain = settings.block<2, 1>(0, 1);
  Eigen::ArrayXd ymin = settings.block<2, 1>(0, 2);
  x = (y.array() - ymin) / gain + xoffset;
}

void FK(Eigen::VectorXd X, Eigen::VectorXd& Y) {
  const int xdim = X.rows();
  const int ydim = Y.rows();
  const int l1Dim = 20;
  Eigen::VectorXd xoffset(xdim);
  Eigen::VectorXd gain(xdim);
  Eigen::VectorXd ymin(xdim);
  xoffset << -0.91427, -0.901629;
  gain << 0.919497531379003, 0.902283589536758;
  ymin << -1, -1;
  Eigen::MatrixXd x1_step1(xdim, 3);
  x1_step1 << xoffset, gain, ymin;

  Eigen::MatrixXd IW1_1(l1Dim, xdim), LW2_1(ydim, l1Dim);
  Eigen::VectorXd b1(l1Dim), b2(ydim);
  b1 << -6.384639165828828844, -3.185326650382202196, 2.9699869874982773865, -2.3733150435436543013,
      -1.4566349380730339025, 1.2355965239484443252, 1.7346084458359045666, -0.84850659299591146834,
      -0.021144815958427095465, -0.055260765697361546867, -0.08340570724541926384, 0.15813104653275464329,
      1.1706741563136948692, -1.2869844244301134051, 2.0477804220971469462, -4.0005510755915132393,
      -3.3898244583139067743, 4.5207011266642194158, 5.8776088192750526318, 6.0306850355662291463;
  IW1_1 << 6.0162134327360110575, 0.061069755885851458033, 3.4054324188801357032, -3.0967211155861482652,
      -2.8069535727940091441, 1.7057775718910199725, 1.3850883234366757613, 2.0169469420953984873,
      3.3364745205218468982, 2.9646037880186528746, -1.9475133595578415502, 0.54640133595543238787,
      -0.57474468666686406859, 1.614473456445862265, 0.94412418114617280285, -1.780588752649727935,
      2.0063764782181148227, 0.057569611784411708899, 1.1225532816514744994, -0.53391681952391245591,
      -4.8163217499420616363, 1.8435606266338899761, 0.47117645639884325748, -0.90451409811633098901,
      1.475663932412925039, -0.64317392094265846136, 0.82342763514162220506, -3.8143347168239252198,
      1.5594612127479925423, -2.6911615584044001892, -1.5353170784954184303, 3.724458791100646593,
      -0.77162528514215811271, 2.8208108064935366599, 4.1085572930333817965, 0.73185219162282111327,
      1.4324074946855229751, 5.363160397265041901, 5.351938822519591632, -2.8534358856666024451;

  b2 << -0.73589463812333943959, 0.26057881821025463687;
  LW2_1 << -0.037232990518905224875, -0.0074158846206535808041, -0.026015504177081497095, 0.042628604991951091208,
      0.00076500331956603801354, -0.19195653791701253188, 0.31071248856262467797, -0.10270733358064618179,
      0.015829153771047013016, 1.0763615830365269588, 0.0012050292072412168484, -1.4684268876308490537,
      0.49614333080280503818, -0.001486407786691465796, -0.056087689510853043495, 0.36435434386639714566,
      -0.82094932768155470804, 0.00050349537455654882513, -0.0015996053972284418002, 0.18764508455414230514,
      -0.06163131255451390067, 0.21679842120080927703, 0.64153112881528961964, 0.0020167867257671191587,
      0.00097357639445004367715, -0.11381267392057342613, -0.44851801917831718436, 0.2732098673253473553,
      0.021057790517641204048, 0.53060438530573672544, -0.00017832021992295231318, 1.015536281093459392,
      0.72290286633910072478, -0.0056348057382486164274, 0.00034747313972555008473, -0.35688737478915277812,
      1.2250085842199895936, 0.021031716987545519965, -0.012448827672558383101, 0.098123512947404470386;

  xoffset << -0.610865, -0.349066;
  gain << 1.43266886151536, 3.02114347259294;
  ymin << -1, -1;
  Eigen::MatrixXd y1_step1(xdim, 3);
  y1_step1 << xoffset, gain, ymin;

  Eigen::VectorXd Xp1, a1, a2;

  MapminmaxApply(X, x1_step1, Xp1);

  TansigApply(b1 + IW1_1 * Xp1, a1);
  a2 = b2 + LW2_1 * a1;

  MapminmaxReverse(a2, y1_step1, Y);
}
}  // namespace estimator
}  // namespace core
